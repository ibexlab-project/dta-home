# Next.js Project Rules

## 1. 작업 진행 프로세스

### 1.1 작업 전 확인 사항
- 모든 작업을 시작하기 전에 반드시 다음을 설명하고 사용자의 승인을 받아야 합니다:
  - 문제 분석 및 해결 방안
  - 변경할 파일 목록
  - 예상 결과 및 범위
- 사용자의 명시적인 승인 없이는 코드 수정을 진행하지 않습니다.

### 1.2 커뮤니케이션
- 사용자와의 대화는 항상 한국어로 진행합니다.
- 코드, 주석, 변수명, 함수명은 모두 영어로 작성합니다.
- UI에 표시되는 텍스트는 영어로 작성합니다 (다국어 지원이 필요한 경우 별도 처리).

## 2. Next.js 프로젝트 구조

### 2.1 App Router 우선 사용
- Next.js 13+ 버전을 사용하는 경우 App Router를 우선적으로 사용합니다.
- `app/` 디렉토리 구조를 따릅니다:
  - `app/layout.tsx`: 루트 레이아웃
  - `app/page.tsx`: 홈 페이지
  - `app/[route]/page.tsx`: 동적 라우트
  - `app/api/[route]/route.ts`: API 라우트

### 2.2 Server Components 기본 사용
- 기본적으로 Server Components를 사용합니다.
- 클라이언트 상호작용이 필요한 경우에만 `'use client'` 지시어를 사용합니다.
- Client Components는 최소한으로 유지하고 필요한 부분만 클라이언트로 분리합니다.

### 2.3 파일 및 폴더 네이밍
- 파일명: `kebab-case` 사용 (예: `user-profile.tsx`, `api-handler.ts`)
- 컴포넌트명: `PascalCase` 사용 (예: `UserProfile`, `ApiHandler`)
- 폴더명: `kebab-case` 사용
- 페이지 파일: `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`, `not-found.tsx` 사용
- API 라우트: `route.ts` 사용

## 3. TypeScript 규칙

### 3.1 엄격한 타입 사용
- `any` 타입 사용을 금지합니다.
- 모든 함수, 변수, 컴포넌트에 명시적 타입을 지정합니다.
- 인터페이스와 타입 별칭을 적절히 활용합니다.

### 3.2 타입 정의 위치
- 컴포넌트별 타입은 해당 파일 내부에 정의합니다.
- 공통 타입은 `types/` 또는 `@/types` 디렉토리에 정의합니다.
- API 응답 타입은 `types/api/` 디렉토리에 정의합니다.

## 4. React 컴포넌트 규칙

### 4.1 컴포넌트 구조
- 함수형 컴포넌트만 사용합니다.
- 컴포넌트는 단일 책임 원칙(SRP)을 따릅니다.
- 하나의 컴포넌트는 하나의 명확한 목적만 가져야 합니다.

### 4.2 컴포넌트 크기
- 함수는 20줄 이하로 유지합니다.
- 복잡한 로직은 커스텀 훅이나 유틸리티 함수로 분리합니다.
- 컴포넌트가 너무 길어지면 더 작은 컴포넌트로 분리합니다.

### 4.3 Props 타입 정의
- 모든 Props는 인터페이스로 명시적으로 정의합니다.
- Optional props는 `?`를 사용하여 표시합니다.
- 기본값은 기본 매개변수나 defaultProps를 사용합니다.

```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export function Button({ label, onClick, variant = 'primary', disabled = false }: ButtonProps) {
  // ...
}
```

## 5. 코드 스타일 및 품질

### 5.1 함수 작성 규칙
- 함수명은 동사로 시작하고 명확한 의미를 전달합니다.
- 불리언 변수/함수는 `is`, `has`, `should` 등의 접두사를 사용합니다.
- 화살표 함수를 단순한 경우에 사용합니다.
- 고차 함수를 활용하여 중첩을 피합니다.

### 5.2 에러 처리
- 예외는 예상치 못한 오류에만 사용합니다.
- 예상 가능한 오류는 명시적으로 처리합니다.
- API 호출 시 try-catch를 사용하여 에러를 처리합니다.

### 5.3 SOLID 원칙 준수
- 단일 책임 원칙(SRP): 각 함수/컴포넌트는 하나의 책임만 가집니다.
- 개방-폐쇄 원칙(OCP): 확장에는 열려있고 수정에는 닫혀있습니다.
- 리스코프 치환 원칙(LSP): 하위 타입은 상위 타입을 대체할 수 있어야 합니다.
- 인터페이스 분리 원칙(ISP): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않습니다.
- 의존성 역전 원칙(DIP): 고수준 모듈은 저수준 모듈에 의존하지 않아야 합니다.

### 5.4 상속보다는 컴포지션
- 클래스 상속보다는 컴포지션을 선호합니다.
- 공통 로직은 커스텀 훅이나 유틸리티 함수로 추출합니다.

## 6. Next.js 특화 규칙

### 6.1 데이터 페칭
- Server Components에서는 `async/await`를 직접 사용합니다.
- Client Components에서는 `useEffect`와 `useState` 또는 SWR/React Query를 사용합니다.
- API Routes는 RESTful 원칙을 따릅니다.

### 6.2 메타데이터 관리
- `app/` 디렉토리에서는 `metadata` 객체를 export하여 SEO를 관리합니다.
- 동적 메타데이터는 `generateMetadata` 함수를 사용합니다.

### 6.3 이미지 최적화
- `next/image` 컴포넌트를 사용하여 이미지를 최적화합니다.
- 적절한 `width`, `height`, `alt` 속성을 항상 제공합니다.

### 6.4 라우팅
- 파일 시스템 기반 라우팅을 사용합니다.
- 동적 라우트는 `[param]` 형식을 사용합니다.
- Catch-all 라우트는 `[...slug]` 형식을 사용합니다.

### 6.5 API Routes
- API Routes는 `route.ts` 파일에 정의합니다.
- HTTP 메서드별로 함수를 export합니다: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`
- 에러 응답은 적절한 HTTP 상태 코드를 반환합니다.

```typescript
// app/api/users/route.ts
export async function GET(request: Request) {
  try {
    // ...
    return Response.json({ data }, { status: 200 });
  } catch (error) {
    return Response.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

## 7. 스타일링 규칙

### 7.1 Tailwind CSS 사용 (기본)
- 스타일링은 **Tailwind CSS** 사용을 기본 원칙으로 합니다.
- 유틸리티 클래스를 우선적으로 사용하여 스타일을 적용합니다.
- 복잡한 스타일 조합이 필요한 경우 `clsx` 또는 `tailwind-merge`와 같은 유틸리티를 활용합니다.
- CSS Modules는 특별한 사유가 없는 한 사용을 지양합니다.

### 7.2 반응형 디자인
- 모바일 퍼스트 접근 방식을 사용합니다.
- 적절한 breakpoint를 사용하여 반응형 레이아웃을 구현합니다.

## 8. 성능 최적화

### 8.1 코드 분할
- 동적 import를 사용하여 필요한 경우에만 코드를 로드합니다.
- 큰 라이브러리는 동적으로 import합니다.

### 8.2 캐싱
- Next.js의 캐싱 전략을 적절히 활용합니다.
- `fetch` 옵션에서 `cache` 설정을 명시합니다.
- `revalidate` 옵션을 사용하여 ISR을 활용합니다.

### 8.3 번들 크기 최적화
- 불필요한 의존성을 제거합니다.
- Tree-shaking이 가능하도록 import를 최적화합니다.

## 9. 접근성 (A11y)

### 9.1 시맨틱 HTML
- 적절한 HTML 시맨틱 태그를 사용합니다.
- `button`, `a`, `input` 등 적절한 요소를 사용합니다.

### 9.2 ARIA 속성
- 필요시 ARIA 속성을 사용하여 접근성을 향상시킵니다.
- `aria-label`, `aria-describedby` 등을 적절히 사용합니다.

### 9.3 키보드 네비게이션
- 모든 인터랙티브 요소는 키보드로 접근 가능해야 합니다.
- 포커스 관리에 주의를 기울입니다.

## 10. 테스트

### 10.1 테스트 구조
- 테스트는 Arrange-Act-Assert 패턴을 따릅니다.
- 각 테스트는 독립적으로 실행 가능해야 합니다.

### 10.2 테스트 파일 위치
- 컴포넌트 테스트: `__tests__/` 디렉토리 또는 `*.test.tsx` 형식
- 유틸리티 테스트: `*.test.ts` 형식

## 11. 환경 변수 관리

### 11.1 환경 변수 네이밍
- 환경 변수는 `UPPERCASE_SNAKE_CASE` 형식을 사용합니다.
- Next.js의 환경 변수 규칙을 따릅니다:
  - 클라이언트에서 사용: `NEXT_PUBLIC_` 접두사
  - 서버에서만 사용: 접두사 없음

### 11.2 환경 변수 파일
- `.env.local`: 로컬 개발 환경
- `.env.example`: 예시 파일 (실제 값 제외)

## 12. 에러 처리 및 로깅

### 12.1 에러 바운더리
- `error.tsx` 파일을 사용하여 에러를 처리합니다.
- 사용자에게 친화적인 에러 메시지를 표시합니다.

### 12.2 로깅
- 프로덕션에서는 적절한 로깅 서비스를 사용합니다.
- 민감한 정보는 로그에 포함하지 않습니다.

## 13. 보안

### 13.1 입력 검증
- 모든 사용자 입력을 검증합니다.
- 서버 사이드에서도 검증을 수행합니다.

### 13.2 XSS 방지
- 사용자 입력을 렌더링할 때 적절히 이스케이프합니다.
- `dangerouslySetInnerHTML` 사용을 최소화합니다.

### 13.3 CSRF 보호
- API Routes에서 적절한 CSRF 보호를 구현합니다.

## 14. 문서화

### 14.1 코드 주석
- 복잡한 로직에는 주석을 추가합니다.
- 함수의 목적과 매개변수, 반환값을 설명합니다.

### 14.2 README
- 프로젝트 루트에 `README.md`를 유지합니다.
- 설치, 실행, 배포 방법을 명시합니다.

## 15. Git 및 버전 관리

### 15.1 커밋 메시지
- 커밋 메시지는 간결하고 명확하게 작성합니다.
- 짧은 제목과 간단한 내용으로 구성합니다.

### 15.2 브랜치 전략
- 프로젝트의 브랜치 전략을 따릅니다.
- 기능별로 브랜치를 분리합니다.

## 16. 기타 규칙

### 16.1 외부 라이브러리
- 새로운 라이브러리를 추가하기 전에 프로젝트에 필요한지 검토합니다.
- 유지보수가 활발하고 널리 사용되는 라이브러리를 선호합니다.

### 16.2 코드 리뷰
- 코드 변경사항은 리뷰를 거칩니다.
- 피드백을 적극적으로 수용합니다.

### 16.3 리팩토링
- 코드 냄새를 발견하면 적절히 리팩토링합니다.
- 근본적인 해결책을 구현하는 것을 선호합니다 (패치워크 수정 지양).
